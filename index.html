<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- Zorgt ervoor dat de app mooi opent op iPad zonder browserbalken -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Radio Donald">

    <!-- Icoontjes voor iPad scherm en browser tabblad (lokaal bestand: duck.png) -->
    <link rel="apple-touch-icon" href="duck.png">
    <link rel="icon" type="image/png" href="duck.png">

    <title>Radio Donald Podcast</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@700&display=swap');

        body {
            font-family: 'Nunito', sans-serif;
            background-color: #f0f9ff; /* Luchtblauw */
            background-image: radial-gradient(#bae6fd 15%, transparent 16%), radial-gradient(#bae6fd 15%, transparent 16%);
            background-size: 60px 60px;
            background-position: 0 0, 30px 30px;
            touch-action: manipulation; /* Voorkomt zoomen op iPad */
            /* Zorgt dat je niet per ongeluk naar beneden trekt om te verversen op iPad (in standalone modus) */
            overscroll-behavior-y: none; 
        }

        h1 {
            font-family: 'Fredoka One', cursive;
            text-shadow: 2px 2px 0px #fff, 4px 4px 0px rgba(0,0,0,0.1);
        }

        .btn-main {
            transition: all 0.1s;
            box-shadow: 0 6px 0 rgba(0,0,0,0.2);
        }
        .btn-main:active {
            transform: translateY(6px);
            box-shadow: 0 0px 0 rgba(0,0,0,0.2);
        }

        .on-air {
            animation: pulse-red 1.5s infinite;
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }

        .ipad-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        /* Simpele styling voor de audio speler */
        audio {
            width: 100%;
            height: 40px;
            border-radius: 20px;
        }
    </style>
</head>
<body class="text-gray-800">

<div class="ipad-container p-4 max-w-2xl mx-auto">
    
    <!-- Header -->
    <header class="text-center mb-6">
        <div class="inline-block bg-yellow-400 p-4 rounded-full border-4 border-white shadow-lg mb-2">
            <i class="fas fa-microphone-alt text-4xl text-orange-600"></i>
        </div>
        <h1 class="text-4xl text-blue-600 mb-1">Radio Donald</h1>
        <p class="text-blue-400 font-bold">De Podcast Maker</p>
    </header>

    <!-- Status & Visualizer -->
    <div class="bg-white rounded-3xl p-6 shadow-xl border-b-8 border-gray-200 mb-6 relative overflow-hidden">
        <div id="statusLabel" class="absolute top-4 right-4 bg-gray-200 text-gray-500 px-3 py-1 rounded-full font-bold text-xs uppercase tracking-wider transition-colors duration-300">
            Stand-by
        </div>
        
        <div class="flex flex-col items-center justify-center h-32 space-y-2">
            <div id="timer" class="text-5xl font-black text-gray-700 font-mono">00:00</div>
            <div class="h-8 flex items-center justify-center space-x-1 w-full" id="visualizer">
                <div class="w-2 h-2 bg-blue-200 rounded-full animate-bounce"></div>
                <div class="w-2 h-2 bg-blue-300 rounded-full animate-bounce" style="animation-delay: 0.1s"></div>
                <div class="w-2 h-2 bg-blue-400 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
            </div>
        </div>
    </div>

    <!-- Controls -->
    <div class="grid grid-cols-2 gap-4 mb-6">
        <button onclick="playIntro()" class="btn-main bg-blue-500 hover:bg-blue-600 text-white rounded-2xl p-6 flex flex-col items-center justify-center border-b-8 border-blue-700">
            <i class="fas fa-music text-3xl mb-2"></i>
            <span class="font-bold text-lg">Intro Muziek</span>
        </button>

        <button onclick="playPageTurn()" class="btn-main bg-orange-400 hover:bg-orange-500 text-white rounded-2xl p-6 flex flex-col items-center justify-center border-b-8 border-orange-600">
            <i class="fas fa-book-open text-3xl mb-2"></i>
            <span class="font-bold text-lg">Bladzijde</span>
        </button>
    </div>

    <!-- Recording Control -->
    <div class="flex justify-center mb-6">
        <button id="recordBtn" onclick="toggleRecording()" class="btn-main w-full bg-red-500 hover:bg-red-600 text-white rounded-3xl p-6 flex items-center justify-center border-b-8 border-red-700 transform transition">
            <div class="flex items-center space-x-4">
                <div class="bg-white/20 p-3 rounded-full">
                    <i id="recordIcon" class="fas fa-circle text-2xl"></i>
                </div>
                <span id="recordText" class="text-2xl font-black uppercase tracking-wide">Start Opname</span>
            </div>
        </button>
    </div>

    <!-- Processing Indicator -->
    <div id="processingArea" class="hidden text-center p-4 bg-yellow-50 rounded-2xl border-2 border-yellow-200 mb-4 animate-pulse">
        <p class="text-yellow-700 font-bold"><i class="fas fa-cog fa-spin mr-2"></i>Even geduld, audio omzetten...</p>
    </div>

    <!-- Download & Preview & Reset Area -->
    <div id="downloadArea" class="hidden animate-fade-in flex flex-col space-y-3">
        
        <!-- Audio Player Preview -->
        <div class="bg-white p-3 rounded-2xl border-2 border-blue-200 shadow-sm">
             <p class="text-xs text-blue-400 font-bold mb-1 uppercase text-center">Luister terug</p>
             <audio id="audioPreview" controls class="w-full outline-none"></audio>
        </div>

        <!-- Download Box -->
        <div class="bg-green-100 border-2 border-green-400 rounded-2xl p-4 flex items-center justify-between">
            <div class="flex items-center space-x-3">
                <div class="bg-green-500 text-white p-2 rounded-full">
                    <i class="fas fa-file-audio"></i>
                </div>
                <div>
                    <p class="font-bold text-green-800">Klaar!</p>
                    <p class="text-xs text-green-600">Hoge kwaliteit (.WAV)</p>
                </div>
            </div>
            <a id="downloadLink" href="#" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-xl shadow-md transform active:scale-95 transition flex items-center">
                <i class="fas fa-download mr-2"></i> Opslaan
            </a>
        </div>

        <!-- Reset Button -->
        <button onclick="resetApp()" class="w-full bg-gray-200 hover:bg-gray-300 text-gray-600 font-bold py-3 px-4 rounded-xl border-2 border-gray-300 transform active:scale-95 transition flex items-center justify-center">
            <i class="fas fa-trash-alt mr-2"></i> Alles wissen en opnieuw beginnen
        </button>
    </div>

</div>

<script>
    let audioCtx;
    let mediaRecorder;
    let audioChunks = [];
    let isRecording = false;
    let startTime;
    let timerInterval;

    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }

    // --- Sound Effects ---
    function playIntro() {
        initAudio();
        const now = audioCtx.currentTime;
        const notes = [261.63, 329.63, 392.00, 523.25, 392.00, 329.63, 261.63];
        const times = [0, 0.2, 0.4, 0.6, 0.9, 1.1, 1.4];
        const lengths = [0.2, 0.2, 0.2, 0.3, 0.2, 0.2, 0.4];

        notes.forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.type = i === 3 ? 'square' : 'sine';
            osc.frequency.value = freq;
            gainNode.gain.setValueAtTime(0.1, now + times[i]);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + times[i] + lengths[i]);
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            osc.start(now + times[i]);
            osc.stop(now + times[i] + lengths[i]);
        });
    }

    function playPageTurn() {
        initAudio();
        const bufferSize = audioCtx.sampleRate * 0.5;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(800, audioCtx.currentTime);
        filter.frequency.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
        const gainNode = audioCtx.createGain();
        gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
        noise.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        noise.start();
    }

    // --- Recording & WAV Conversion ---

    async function toggleRecording() {
        initAudio();
        const btn = document.getElementById('recordBtn');
        const icon = document.getElementById('recordIcon');
        const text = document.getElementById('recordText');
        const status = document.getElementById('statusLabel');
        const downloadArea = document.getElementById('downloadArea');
        const processingArea = document.getElementById('processingArea');
        const audioPreview = document.getElementById('audioPreview');

        if (!isRecording) {
            try {
                // Reset preview just in case
                audioPreview.pause();
                audioPreview.src = "";

                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];

                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    processingArea.classList.remove('hidden');
                    
                    // Create basic blob
                    const audioBlob = new Blob(audioChunks);
                    
                    // Convert to WAV
                    try {
                        const arrayBuffer = await audioBlob.arrayBuffer();
                        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                        const wavBlob = bufferToWave(audioBuffer, audioBuffer.length);
                        const audioUrl = URL.createObjectURL(wavBlob);
                        
                        // Setup Download Link
                        const link = document.getElementById('downloadLink');
                        link.href = audioUrl;
                        const date = new Date();
                        const filename = `RadioDonald_${date.getHours()}-${String(date.getMinutes()).padStart(2, '0')}.wav`;
                        link.download = filename;

                        // Setup Audio Player
                        audioPreview.src = audioUrl;

                        processingArea.classList.add('hidden');
                        downloadArea.classList.remove('hidden');
                    } catch (e) {
                        console.error("Conversie fout", e);
                        alert("Er ging iets mis met opslaan. Probeer opnieuw.");
                        processingArea.classList.add('hidden');
                    }
                };

                mediaRecorder.start();
                
                isRecording = true;
                btn.classList.remove('bg-red-500', 'hover:bg-red-600', 'border-red-700');
                btn.classList.add('bg-gray-700', 'hover:bg-gray-800', 'border-gray-900');
                icon.classList.remove('fa-circle');
                icon.classList.add('fa-stop', 'text-red-500');
                text.innerText = "Stop Opname";
                status.innerText = "ON AIR";
                status.classList.remove('bg-gray-200', 'text-gray-500');
                status.classList.add('bg-red-600', 'text-white', 'on-air');
                
                downloadArea.classList.add('hidden');
                processingArea.classList.add('hidden');

                startTimer();

            } catch (err) {
                console.error(err);
                alert("Geen toegang tot microfoon.");
            }
        } else {
            mediaRecorder.stop();
            mediaRecorder.stream.getTracks().forEach(track => track.stop());

            isRecording = false;
            btn.classList.add('bg-red-500', 'hover:bg-red-600', 'border-red-700');
            btn.classList.remove('bg-gray-700', 'hover:bg-gray-800', 'border-gray-900');
            icon.classList.add('fa-circle');
            icon.classList.remove('fa-stop', 'text-red-500');
            text.innerText = "Nieuwe Opname";

            status.innerText = "Stand-by";
            status.classList.add('bg-gray-200', 'text-gray-500');
            status.classList.remove('bg-red-600', 'text-white', 'on-air');

            stopTimer();
        }
    }

    function resetApp() {
        // Reset Audio Player
        const audioPreview = document.getElementById('audioPreview');
        audioPreview.pause();
        audioPreview.src = "";

        // Hide download area
        const downloadArea = document.getElementById('downloadArea');
        downloadArea.classList.add('hidden');

        // Reset timer display
        document.getElementById('timer').innerText = "00:00";

        // Clear audio chunks
        audioChunks = [];
        
        // Reset recording state just in case
        isRecording = false;
        
        // Reset button state (should already be correct, but to be sure)
        const btn = document.getElementById('recordBtn');
        const icon = document.getElementById('recordIcon');
        const text = document.getElementById('recordText');
        const status = document.getElementById('statusLabel');

        btn.classList.add('bg-red-500', 'hover:bg-red-600', 'border-red-700');
        btn.classList.remove('bg-gray-700', 'hover:bg-gray-800', 'border-gray-900');
        icon.classList.add('fa-circle');
        icon.classList.remove('fa-stop', 'text-red-500');
        text.innerText = "Start Opname";

        status.innerText = "Stand-by";
        status.classList.add('bg-gray-200', 'text-gray-500');
        status.classList.remove('bg-red-600', 'text-white', 'on-air');
    }

    function startTimer() {
        startTime = Date.now();
        timerInterval = setInterval(() => {
            const delta = Date.now() - startTime;
            const seconds = Math.floor((delta / 1000) % 60);
            const minutes = Math.floor((delta / (1000 * 60)) % 60);
            document.getElementById('timer').innerText = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }, 1000);
        document.querySelectorAll('#visualizer div').forEach(div => {
            div.style.animationDuration = '0.5s';
        });
    }

    function stopTimer() {
        clearInterval(timerInterval);
        document.querySelectorAll('#visualizer div').forEach(div => {
            div.style.animationDuration = '0s';
        });
    }

    // --- WAV Conversion Helper Function ---
    function bufferToWave(abuffer, len) {
        let numOfChan = abuffer.numberOfChannels,
            length = len * numOfChan * 2 + 44,
            buffer = new ArrayBuffer(length),
            view = new DataView(buffer),
            channels = [], i, sample,
            offset = 0,
            pos = 0;

        // write WAVE header
        setUint32(0x46464952);                         // "RIFF"
        setUint32(length - 8);                         // file length - 8
        setUint32(0x45564157);                         // "WAVE"

        setUint32(0x20746d66);                         // "fmt " chunk
        setUint32(16);                                 // length = 16
        setUint16(1);                                  // PCM (uncompressed)
        setUint16(numOfChan);
        setUint32(abuffer.sampleRate);
        setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
        setUint16(numOfChan * 2);                      // block-align
        setUint16(16);                                 // 16-bit (hardcoded in this function)

        setUint32(0x61746164);                         // "data" - chunk
        setUint32(length - pos - 4);                   // chunk length

        // write interleaved data
        for(i = 0; i < abuffer.numberOfChannels; i++)
            channels.push(abuffer.getChannelData(i));

        while(pos < len) {
            for(i = 0; i < numOfChan; i++) {             // interleave channels
                sample = Math.max(-1, Math.min(1, channels[i][pos])); // clamp
                sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0; // scale to 16-bit signed int
                view.setInt16(44 + offset, sample, true);          // write 16-bit sample
                offset += 2;
            }
            pos++;
        }

        return new Blob([buffer], {type: "audio/wav"});

        function setUint16(data) {
            view.setUint16(pos, data, true);
            pos += 2;
        }

        function setUint32(data) {
            view.setUint32(pos, data, true);
            pos += 4;
        }
    }
</script>
</body>
</html>
